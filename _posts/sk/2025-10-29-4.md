---
title:  "Rookies 4일차: Python 개념 학습 3"
excerpt: "파이썬의 분기&반복문, 함수, 연산자에 대해 자세히 알아보자."

categories: sk
tags:
  - [sk, python]

typora-root-url: ../../
 
date: 2025-10-29
last_modified_at: 2025-10-29
published: true



---

**☀️<u>공지 사항</u>☀️** 해당 게시글은 `SK 쉴더스 루키즈, 생성형AI 활용 사이버보안 전문인력 양성과정` 을 수업을 듣고 정리한 글입니다. 자세한 교육 정보는  [SK 쉴더스 홈페이지](https://sslc.kr/) 를 확인해주세요.
{: .notice--danger}


# 학습 내용 요약 (25/10/29)



## 1. 분기문 (Conditional Statements)

파이썬에서 `if`, `elif`, `else`를 사용한 분기문(조건문)은 특정 조건에 따라 프로그램의 흐름을 제어한다. 이는 특히 보안에서 **입력 값 검증**이나 **접근 제어 로직**을 구현할 때 매우 중요하다.

### 1.1 기본 구조

Python

```python
if (논리값 또는 표현식) :
    # 실행 코드
elif (논리값 또는 표현식) :
    # 실행 코드
else :
    # 실행 코드
```


​    
### 1.2 활용 예시

#### 1.2.1 점수 등급 판별
입력받은 점수(`Score`)를 기준으로 `A+`, `A-`, `B`, `C`, `D`, `F` 등급을 나누는 중첩(`nested`) `if`와 `elif` 구조를 사용했다.
```python
score = int(input('점수를 입력하세요 : '))
print('type - ' , type(score))
if score >= 90 :
    if score >= 95 :
        print('A+')
    else :
        print('A-')
elif score >= 80 :
    print('B')
elif score >= 70 :
    print('C')
elif score >= 60 :
    print('D')
else :
    print('F') 
```


#### 1.2.2 윤년 판별 (Quiz)
연도(`Year`)가 4의 배수이고 100의 배수가 아니거나( `and`, `or` 논리 연산자 사용) 400의 배수일 때를 **윤년**으로 판단하는 복합 조건을 처리했다.
```python
year = int(input('년도를 입력하세요. : '))
if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
    print('윤년입니다.')
else:
    print('윤년이 아닙니다.')
```


#### 1.2.3 컬렉션 포함 여부 (`in`)
리스트(`areas`)나 딕셔너리(`dictTmp`)에서 특정 요소나 키의 **존재 유무**를 `if ... in ...` 구문을 이용해 확인했다. 이는 **화이트리스트/블랙리스트** 기반의 접근 제어 로직 구현에 응용될 수 있다.
```python
dictTmp = {'melon' : 100 , 'bravo' : 200 , 'bibibig' : 300 } 
print('키 존재 유무를 판단하고 싶다면 - ') 
target = 'banana' 
print('논리값 - ' ,  target in dictTmp )
if target in dictTmp : 
    print(dictTmp[target])
else :
    print(f'{target} 키는 대상이 아닙니다.')
```


---

## 2. 삼항 연산자 (Ternary Operator)

파이썬의 삼항 연산자는 조건에 따라 두 개의 값 중 하나를 선택하는 간결한 방법을 제공하며, 한 줄로 간단한 분기 로직을 표현할 때 유용하다.

### 2.1 기본 구조
`[조건의 결과] if [조건] else [else의 결과]`

### 2.2 활용 예시

- 두 변수 중 **최댓값**을 결정하는 데 사용했다.

- **리스트 컴프리헨션** 내에서 사용해 리스트의 각 요소가 **짝수**인지 **홀수**인지를 효율적으로 판별했다.

- **중첩 삼항 연산**을 통해 핸드폰 번호의 접두사(`Prefix`)에 따라 **통신사**를 확인하는 로직을 구현했다. 이는 코드의 가독성을 해칠 수 있으므로 복잡한 조건에서는 지양하는 것이 좋다.


#### 중첩 삼항 연산을 활용한 코드 예시

```python
# 통신사의 정보를 확인
phone = input('핸드폰 번호를 입력하세요 ex) xxx-xxxx-xxxx :')

prefix = phone.split('-')[0]

result =    "SK" if prefix == '011' else "KT" if prefix == '016' else "LG" if prefix == '019' else 'eroor'

print(result)

----------------------------------------------------------------------
# input 함수를 이용해서 주민번호 입력 ex) xxxxxx-x09xxxx 출생지가 서울인지 아닌지 판단

ssn = input('ssn number: ')

seoulCity = ["00", "01", "02", "03", "04", "05", "06", "07", "08"]

if ssn.split('-')[1][1:3] in seoulCity :
    print('서울 출생')
else :
    print('지방 출생')

# 삼항 연상자로 해보기
print('case02 - ')
print('서울') if ssn.split('-')[1][1:3] in seoulCity else print('지방 출생')
```


## 3. 반복문 (Loop Statements)

`for`와 `while` 반복문은 코드 블록을 여러 번 실행하는 데 사용되며, `break`와 `continue`는 반복 흐름을 제어한다. **파일 처리**, **로그 분석**, **대규모 데이터 처리** 등에서 필수적인 구문이다.

- **`for` 반복문**: `range`, 리스트, 튜플, 딕셔너리 등 **열거형** 데이터의 요소를 순회한다.
  
    - `enumerate`: 데이터와 그 **인덱스**를 동시에 순회
      
    - 단어 리스트에서 각 단어의 **빈도수**를 계산하는 로직을 구현 가능
      
    - **구구단**을 출력하는 이중 `for` 루프 활용
    
- **`for ~ else` / `while ~ else`**: `for` 또는 `while` 루프가 `break` 없이 정상적으로 완료되었을 때만 `else` 블록의 코드가 실행된다. 이는 **숫자 맞히기 게임(Guess Game)**에서 기회(`MaxTries`)를 모두 사용했을 때의 메시지를 출력하는 데 활용되었다.
  
- **`while` 반복문**: 조건식이 참인 동안 반복 실행된다. **시작 날짜**부터 **종료 날짜**까지의 리스트를 생성하는 데 `while` 루프와 `timedelta`를 함께 사용했다.


`timedelta` 코드 예시

```python
from datetime import datetime, timedelta	# <-- 모듈 import 추가!

startDay = datetime.strptime('2025-10-01', '%Y-%m-%d')
endDay = datetime.strptime('2025-10-10', '%Y-%m-%d')
lst = []	# 날짜 리스트 생성
currentDay = startDay

# while 
while currentDay <= endDay :
    lst.append(currentDay.strftime('%Y-%m-%d'))
    currentDay += timedelta(days = 1)
print(lst)

-----------------------------------------------------------------
# 출력 결과
['2025-10-01', '2025-10-02', '2025-10-03', '2025-10-04', '2025-10-05', '2025-10-06', '2025-10-07', '2025-10-08', '2025-10-09', '2025-10-10']
```


## 4. 날짜/시간 처리 모듈 (Date/Time Handling)

정확한 날짜 및 시간 처리는 **로그 분석**, **인증 만료 시간 검증** 등 보안 영역에서 매우 중요하다.

**`datetime` 모듈**:

- `date.today()`: **날짜** 정보만 가져온다.

- `datetime.today()`: **날짜와 시간** 정보(시분초, 마이크로초)까지 가져온다.


**날짜 연산**:
  
- `timedelta`: 날짜 간의 **차이** 또는 **단순 시간 간격**(`days=1`, `hours=3` 등)을 나타낸다. 날짜 객체에 더하거나 뺄 수 있다.

- `dateutil.relativedelta`: `years`, `months` 등 더 **직관적**이고 **복잡한** 날짜 연산을 위해 사용된다.
    
**형식 변환**:
  
- `datetime.strptime(string, format)`: **문자열** 형태의 날짜를 `datetime` 객체로 변환한다.      (문자열)`'2025-10-29'` ->  날짜 객체


- `datetime.strftime(format)`: `datetime` 객체를 원하는 **문자열 형식**으로 변환한다.      - 날짜 객체  -> (문자열)`'2025-10-29'`

- **`calendar.monthrange(year, month)`**: 특정 연도와 월을 입력받아 해당 월의 시작 요일과 **총 일수(마지막 날짜)**를 알려주는 매우 유용한 기능이다.


### (확장) calendar.monthrange
monthrange() 함수는 두 개의 정수 값을 담은 튜플 형태로 결과를 반환한다.

시작 요일 인덱스: 해당 월 1일의 요일을 **0 (월요일)부터 6 (일요일)**까지의 숫자로 반환한다.

총 일수: 해당 월의 마지막 날짜 (예: 28, 29, 30, 31)를 반환한다.



### (심화) 날짜/시간 처리 코드 연습
```python
# ==============================================================================
# 1. 날짜 및 시간 처리 모듈 임포트 (Import Modules)
# ==============================================================================

# dateutil.relativedelta: '1년', '1개월'처럼 직관적이고 큰 단위의 날짜 차이를 계산하는 모듈이다.
from dateutil.relativedelta import relativedelta 
# datetime.timedelta: '24시간', '1일'과 같은 고정된 시간 간격을 나타내는 클래스이다.
# datetime.date: 날짜 정보만을 저장하는 클래스이다.
from datetime import timedelta , date

print('날짜에 대한 연산을 도와주는 모듈 - dateutill')

# 현재 시스템의 날짜를 가져와 Today 변수에 할당한다. (Today: YYYY-MM-DD 형식)
Today = date.today()
print(f'현재 날짜 (Today) - {Today}')


# ==============================================================================
# 2. timedelta를 이용한 단순 날짜 연산
# ==============================================================================

print('\n--- timedelta를 이용한 단순 날짜 연산 (고정 간격) ---')

# 파이썬의 date 객체에는 정수(1)를 직접 더할 수 없다. (주석 처리)
# print(Today + 1 ) # Error: TypeError 발생

# 1일(24시간)의 고정된 시간 간격을 가지는 timedelta 객체를 생성한다.
DayDelta = timedelta(days=1)
print(f'timedelta 객체 (DayDelta) - {DayDelta}') 

# 현재 날짜(Today)에 DayDelta(1일)를 더하여 다음 날짜를 얻는다.
# timedelta는 주로 짧고 고정된 시간 간격 연산에 사용된다.
NextDay = Today + DayDelta
print(f'현재 날짜에 하루를 더한다면: {NextDay}') 


# ==============================================================================
# 3. relativedelta를 이용한 복합 날짜 연산
# ==============================================================================

print('\n--- relativedelta를 이용한 복합 날짜 연산 (가변 간격) ---')

# relativedelta는 '1개월'처럼 월별 일수가 다른 가변적인 간격 연산에 유용하다.
DayRelativeDelta   = relativedelta(days=1)
MonthRelativeDelta = relativedelta(months=1)
YearRelativeDelta  = relativedelta(years=1)
print(f'relativedelta 객체들: 연({YearRelativeDelta}), 월({MonthRelativeDelta}), 일({DayRelativeDelta})')

# 현재 날짜(Today)를 기준으로 순차적으로 날짜를 업데이트한다.
# 1년 뒤의 날짜로 Today를 갱신한다.
Today = Today + YearRelativeDelta
# 갱신된 날짜에서 다시 1개월 뒤의 날짜로 Today를 갱신한다.
Today = Today + MonthRelativeDelta
# 갱신된 날짜에서 다시 1일 뒤의 날짜로 Today를 갱신한다.
Today = Today + DayRelativeDelta

print(f'최종 업데이트된 날짜: {Today}')
```
